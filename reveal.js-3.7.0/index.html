<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Fast, scalable WCOJ graph-pattern matching on in-memory graphs in Spark</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple.css">
    <link rel="stylesheet" href="plugin/chapter-header/chapter-header.css">
    <link rel="stylesheet" href="custom_theme.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-title="Introduction">
            <section data-no-title="true">
                <h2>Fast, scalable WCOJ graph-pattern matching on in-memory graphs in Spark</h2>
                <br>
                <h3>Presented by Per Fuchs</h3>
                <h3>Supervised by Peter Boncz and Bogdan Ghit</h3>
                <h5>Master thesis in Computer Science</h5>
            </section>
            <section>
                <h3>Cyclic queries in graph-pattern matching pose new challenges to relational engines</h3>
                <div class="box">
                    <div class="col-50">
                        <img height="350px" src="img/triangle.svg" alt="Depiction of triangle query"/>
                    </div>
                    <div class="col-50">
                        <img height="350px" src="img/triangle-binary-joins.svg" alt="Depiction of bushy binary join tree"/>
                    </div>
                </div>
                <p>triangles(a, b, c) <- R(a, b), S(b, c), T(c, a)</p>
                <aside class="notes">
                    <ul>
                        <li>Traditionally we have Snowflakes and Star joins.</li>
                        <li>Solved by binary join (two tables joined at a time).</li>
                        <li>intermediary result are in the of size linear to the inputs (PK to FK)</li>
                        <li>but graphs are FK-FK joins on the edge relationship</li>
                        <li>often cyclic</li>
                        <li>traditional binary joins are subotpimal</li>
                        <li>because they lead to huge intermediary results</li>
                        <li>which are bigger than the end result</li>
                        <li>one example: the triangle query</li>
                        <li>solved by the join plan depicted below</li>
                        <li>point out sizes of intermediary resutls O(N<sup>2</sup>)</li>
                        <li>compare to end result size O(N<sup>3/2</sup>)</li>
                        <li>this is generalizable to all queries by the so called AGM bound</li>
                        <li>Explain datalog query: one variable per vertice, one relationship per edge (all for the edge relationship -
                            alias) with attributes according to the edges
                        </li>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>Worst-case optimal joins to the rescue</h3>
                <img height="200px" src="img/triangle.svg" alt="depiction of triangle query">
                <ul>
                    <li>developed 2012 and proven to be worst-case optimal, e.g. for triangles in
                        O(N<sup>3/2</sup>) and in general by the AGM bound
                    </li>
                    <li>Idea: build the join by <i>variable-at-a-time</i> approach</li>
                    <li>no intermediary results</li>
                    <li>high performance for graph-pattern matching is well established: [1] 2015, [2] 2015,
                        [3] 2017, [4] 2018
                    </li>
                    <!--                    TODO citations -->
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Note this is an n-ary join</li>
                        <li>Explain idea</li>
                        <li>idea translated to the triangle query, bind A, bind B, find C's</li>
                        <li>all contraints used as early as possible</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>Our contributions</h3>
                <ol>
                    <li>designing a scalable WCOJ for Spark</li>
                    <ul>
                        <li>Which distribution scheme to use?</li>
                        <li>open-source</li>
                        <li>integrate the WCOJ with Cypher on Apache Spark (stretch goal)</li>
                    </ul>
                    <li>specializing WCOJ to graph pattern matching</li>
                    <ul>
                        <li>former literature indicates that this is the main use case</li>
                    </ul>
                </ol>
                <aside class="notes">
                    <ul>
                        <li>build a scalable WCOJ in Spark</li>
                        <ul>
                            <li>Spark is well accepted in industry</li>
                            <li>open source</li>
                            <li>Neo4J currently builds a Cypher frontend for Spark (stretch goal)</li>
                        </ul>
                        <li>Superiority over binary joins was ALWAYS - in every single paper - shown for graphs</li>
                    </ul>
                </aside>
            </section>
        </section>
        <section data-title="1st contribution: designing a scalable WCOJ in Spark">
            <section data-no-title="true">
                <h1>1st contribution: designing a scalable WCOJ in Spark</h1>
            </section>
            <section>
                <h3>Background: Spark</h3>
                <ul>
                    <li>Spark distributes data over workers</li>
                    <li>computation follows the <i>Bulk synchronous parallel model</i> (local computations, shuffle, local
                        computations, etc)</li>
                    <li>joins work by shuffling the data such that the distribution allows local join algorithms</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>distribution</li>
                        <li>Bulk synchronous model</li>
                        <li>shuffles are expensive due to disk write and reads</li>
                        <li>To be avoided, how to do an n-ary join in Spark?</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>Hypercube shuffle: optimal distribution for n-ary joins</h3>
                <div class="box">
                    <div class="col-50 margin-10">
                        <h4>Idea</h4>
                        <ul>
                            <li>organize <i>p</i> workers in a hypercube</li>
                            <li>one dimension per variable</li>
                            <li>configurable <i>k<sub>i</sub></i> size per dimension</li>
                            <li>such that <i>p = &#x220F;<sub>i</sub> k<sub>i</sub></i></li>
                            <li>proven to be communication optimal</li>
                        </ul>
                    </div>
                    <div class="col-40">
                        <p>triangles(a, b, c) <- R(a, b), S(b, c), T(c, a)</p>
                        <img height="400px" src="img/hypercube.svg" alt="depiction of hypercube for triangle query"/>
                    </div>
                </div>
            </section>
            <section>
                <h3>Hypercube shuffle: optimal distribution for n-ary joins</h3>
                <div class="box">
                    <div class="col-50">
                        <img height="400px" src="img/hypercube-example.svg" alt="depiction of hypercube for triangle query"/>
                    </div>
                    <div class="col-50">
                        <p>triangles(a, b, c) <- R(a, b), S(b, c), T(c, a)</p>
                        <div class="box">
                            <div class="col-30">
                                <table>
                                    <tr>
                                        <th>a</th>
                                        <th>b</th>
                                    </tr>
                                    <tr>
                                        <td class="color-red">1</td>
                                        <td class="color-red">2</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>3</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>4</td>
                                    </tr>
                                    <tr>
                                        <td>3</td>
                                        <td>1</td>
                                    </tr>
                                </table>
                                <p class="color-red">(2, 0, *)</p>
                            </div>
                            <div class="col-30">
                                <table>
                                    <tr>
                                        <th>b</th>
                                        <th>c</th>
                                    </tr>
                                    <tr>
                                        <td>1</td>
                                        <td>2</td>
                                    </tr>
                                    <tr>
                                        <td class="color-blue">2</td>
                                        <td class="color-blue">3</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>4</td>
                                    </tr>
                                    <tr>
                                        <td>3</td>
                                        <td>1</td>
                                    </tr>
                                </table>
                                <p class="color-blue">(*, 0, 1)</p>
                            </div>
                            <div class="col-30">
                                <table>
                                    <tr>
                                        <th>c</th>
                                        <th>a</th>
                                    </tr>
                                    <tr>
                                        <td>1</td>
                                        <td>2</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>3</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>4</td>
                                    </tr>
                                    <tr>
                                        <td class="color-green">3</td>
                                        <td class="color-green">1</td>
                                    </tr>
                                </table>
                                <p class="color-green">(2, *, 1)</p>
                            </div>
                        </div>
                        <div class="box">
                            <div class="col-30"></div>
                        </div>
                        <div class="box">
                            <div class="col-30"></div>
                        </div>
                    </div>
                </div>
                <aside class="notes">
                    <li>duplication!</li>
                </aside>
            </section>
            <section>
                <h3>Hypercube shuffle converges to broadcasting for larger queries</h3>
                <div class="box">
                    <div class="col-50">
                        <img src="img/shares-bar.svg" alt="Barchart showing duplication over bigger queries."/>
                    </div>
                    <div class="col-50">
                        <ul>
                            <li>analysis by theoretic estimation and simulation</li>
                            <li>a lot of duplicated work</li>
                            <li>not scalable in query size</li>
                            <li>not scalable in numbers of workers</li>
                            <li>although being optimal</li>
                        </ul>
                    </div>
                </div>
                <aside class="notes">
                    <ul>
                        <li>study of HC's scalability by us in theory and by simulation</li>
                        <li>converges to full broadcast for bigger queries</li>
                        <li>intuitively this can be explained by the small world principle</li>
                        <li>doubling the amount of workers does not help much</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>Our Solution: replicated <i>EdgeFrame</i></h3>
                <ul>
                    <li>DataFrame specialized for edge relationship</li>
                    <li>replicated on all workers</li>
                    <li>uses compressed sparse row representation</li>
                    <li>offers worst-case optimal join operation</li>
                    <li>easily integrable into existing Spark projects</li>
                    <li>open source</li>
                    <li><i>logically partitioned</i> (open research)</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>explain solution as on slide</li>
                        <li>better than HC because</li>
                        <ul>
                            <li>no query specific communication -> shuffle free joins</li>
                            <li>opens possibilities for new partitiongs</li>
                            <li>due to different angle (later)</li>
                        </ul>
                    </ul>
                </aside>
            </section>
            <section>
                <h3>Do graphs fit into main memory?</h3>
                <div class="box">
                    <div class="col-50">
                        <img src="img/graph-sizes.png"/>
                    </div>
                    <div class="col-50">
                        <ul>
                            <li>Study of openly available graph datasets</li>
                            <ul>
                                <!--                TODO cite snap and lab-->
                                <li>SNAP</li>
                                <li>Laborytory of Web Algorithms</li>
                            </ul>
                            <li>Total # Graphs: 154</li>
                            <li>all but 3 fit into 256GB of RAM</li>
                            <li>Maximum: 552 GB (Facebook 2011)</li>
                        </ul>
                    </div>
                </div>
                <aside class="notes">
                    <ul>
                        <li>Study of snap and Laborytory of Web Algorithms</li>
                        <li>154 graphs</li>
                        <li>all but 3 fit in 256GB</li>
                        <li>biggest fits in 552 GB</li>
                    </ul>
                </aside>
                <!--                TODO generate better diagram -->
                <!--                TODO cite paper? -->

            </section>
            <section>
                <h3>Parallelization via logical partitionings</h3>
                <ul>
                    <li>
                        parallelization via logical partitioning: full dataset is on each worker but each worker only considers parts of it
                    </li>
                    <li>Hypercube</li>
                    <ul>
                        <li>slightly different angle then as distribution scheme</li>
                        <li>can be pushed into the join</li>
                        <li>in any case, deeper understanding of its scalability</li>
                    </ul>
                    <li>partition on the first attribute to bind by the WCOJ</li>
                    <ul>
<!--                        TODO cite -->
                        <li>fight skew with Intel's adaptive query execution</li>
                    </ul>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>HC itself</li>
                        <li>get a better understanding of its scaling</li>
                        <li>evaluate if the new angle of having all data and being able to push it into the WCOJ enables better scaling</li>
                        <li>Another idea,</li>
                        <ul>
                            <li>WCOJ bind variables in a fixed global order, e.g. a, b, c for the triangle</li>
                            <li>partitiong the first variable</li>
                            <li>sounds simple but this is how searching a tree is parallized in high-performance computing</li>
                            <li>biggest problem skew in the data</li>
                            <li>in high-performance computing: use of workstealing -> adaptive query processing in Spark by Intel</li>
                        </ul>
                    </ul>
                </aside>
            </section>
        </section>
        <section data-title="2nd contribution: specializing WCOJ's">
            <section data-no-title="true">
                <h1>2nd contribution: specializing WCOJ's</h1>
            </section>
            <section>
                <h2>Specializing WCOJ's to graph-pattern matching: idea</h2>
                <ul>
                    <li>code specialization</li>
                    <ul>
                        <li>self-joins only</li>
                        <li>two attributes only</li>
                    </ul>
                    <li>backing data structure: compressed sparse row (CSR)</li>
                    <ul>
                        <li>array access in <i>O(1)</i> instead of binary search in <i>O(log N)</i></li>
                    </ul>
                    <li>logical optimizations</li>
                    <ul>
                        <li>materializing small intersections instead of building them during iteration</li>
                    </ul>
                </ul>
            </section>
            <section>
                <section>
                    <h3>Specializing WCOJ's to graph-pattern matching: results</h3>
<!--                    TODO as speedup graphs instead of in seconds -->
                    <img src="img/results-1.svg" alt="diagram showing Spark joins vs WCOJ vs GraphWCOJ on SNB for a few queries">
                    <img src="img/results-2.svg" alt="diagram showing Spark joins vs WCOJ vs GraphWCOJ on SNB for a few queries">
                    <aside class="notes">
                    </aside>
                </section>
            </section>

        </section>
        <section data-title="Conclusion">
            <section data-no-title="true">
                <h2>Where to find my work?</h2>
                <h3>https://github.com/PerFuchs</h3>
                <p>Also, I'm looking for PhD opportunities or challenging positions in industry.</p>
            </section>
            <section>
                <h2>Take aways</h2>
                <ul>
                    <li>optimal distribution scheme does not scale</li>
                    <li>therefore, replicate</li>
                    <li>WCOJ should be specialized to graphs</li>
                    <li>open source</li>
                </ul>
            </section>
        </section>
        <section data-title="Backup slides">

            <section>
                <h3>List of datasets</h3>
            </section>
            <section>
                <h3>Why are cyclic patterns important?</h3>
                <div class="box">
                    <div>
                        <h4>Facebook friends</h4>
                        <img height="300px" src="img/kite.svg" alt="Depiction of kite query">
                    </div>
                    <div>
                        <h4>Twitter followers</h4>
                        <img height="300px" src="img/diamond.svg" alt="Depiction of diamond query">
                    </div>
                    <div>
                        <h4>Bank fraud</h4>
                        <img height="300px" src="img/5-cycle.svg" alt="Depiction of 5 cycle">
                    </div>
                </div>
                <!--                TODO citations -->
                <aside class="notes">
                    <p>the kite: an example for friends recommendation, see two triangles</p>
                    <p>diamond: used by twitter in production to recommend people to follow (2014 paper)</p>
                    <p>circular money flows indicate bank fraud (white paper Neo4J)</p>
                </aside>
            </section>

        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script src="plugin/highlight/highlight.js"></script>

<script>
    Reveal.initialize({
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/chapter-header/chapter-header.js', async: true, callback: function () {
                    chapterHeader.init();
                }
            }
        ],
        controls: false,
        width: 1500,
        margin: 0.05,
        center: true,
        transition: "none"
    });
    Reveal.configure({slideNumber: true});
    Reveal.configure({slideNumber: 'c/t'});
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>
